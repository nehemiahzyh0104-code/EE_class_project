import time
import mujoco as mj
from mujoco.glfw import glfw
import numpy as np
import os
import scipy as sp
from scipy.spatial.transform import Rotation
import math

xml_path = '../../models/universal_robots_ur5e/scene.xml'  # xml file
simend = 100  # simulation time (second)
print_camera_config = 0  # set to 1 to print camera config

# For callback functions
button_left = False
button_middle = False
button_right = False
lastx = 0
lasty = 0

# Helper function
def random_cube_apex(cx, cy, cz, cube_size=0.1):
    """
    Randomly returns the position of one apex of a cube in 3D space.
    
    Parameters
    ----------
    cx, cy, cz : float
        Center coordinates of the cube
    cube_size : float
        Edge length of the cube.
        
    Returns
    -------
    apex : np.ndarray, shape (3,)
        3D position of a randomly chosen cube apex.
    """
    # Cube center
    center = np.array([cx, cy, cz])
    
    # Half edge length
    h = cube_size / 2.0
    
    # All 8 apex offsets
    offsets = np.array([
        [h, h, h],
        [h, h, -h],
        [h, -h, h],
        [h, -h, -h],
        [-h, h, h],
        [-h, h, -h],
        [-h, -h, h],
        [-h, -h, -h],
    ])
    
    # Randomly select one apex
    apex_offset = offsets[np.random.randint(0, 8)]
    apex = center + apex_offset
    
    return apex

def init_controller(model, data):
    """
    Initialize the controller.
    """
    print("Controller initialized")
    print(f"Model has {model.nq} DOF, {model.nu} actuators")
    
def damped_least_squares(J, damping=0.01):
    """
    Compute damped least squares pseudo-inverse to avoid singularities.
    
    Parameters
    ----------
    J : np.ndarray
        Jacobian matrix (6x6 for UR5e)
    damping : float
        Damping factor to avoid singularities
        
    Returns
    -------
    J_dls_inv : np.ndarray
        Damped least squares pseudo-inverse
    """
    m, n = J.shape
    J_T = J.T
    J_JT = J @ J_T
    damping_matrix = damping**2 * np.eye(m)
    J_dls_inv = J_T @ np.linalg.inv(J_JT + damping_matrix)
    return J_dls_inv

def check_joint_limits(q, model):
    """
    Check and enforce joint limits.
    
    Parameters
    ----------
    q : np.ndarray
        Joint positions
    model : mujoco.MjModel
        MuJoCo model
        
    Returns
    -------
    q_limited : np.ndarray
        Joint positions within limits
    """
    q_limited = q.copy()
    for i in range(len(q)):
        if hasattr(model, 'jnt_range') and model.jnt_range is not None:
            if i < model.jnt_range.shape[0]:
                lower = model.jnt_range[i, 0]
                upper = model.jnt_range[i, 1]
                q_limited[i] = np.clip(q[i], lower, upper)
    return q_limited

def controller(model, data):
    """
    Main controller function - called at each simulation step.
    """
    # This function is not used in the main loop
    # because we're doing IK in the main loop directly
    pass

def keyboard(window, key, scancode, act, mods):
    if act == glfw.PRESS and key == glfw.KEY_BACKSPACE:
        mj.mj_resetData(model, data)
        mj.mj_forward(model, data)
        print("Reset simulation")

def mouse_button(window, button, act, mods):
    # update button state
    global button_left
    global button_middle
    global button_right
    
    button_left = (glfw.get_mouse_button(
        window, glfw.MOUSE_BUTTON_LEFT) == glfw.PRESS)
    button_middle = (glfw.get_mouse_button(
        window, glfw.MOUSE_BUTTON_MIDDLE) == glfw.PRESS)
    button_right = (glfw.get_mouse_button(
        window, glfw.MOUSE_BUTTON_RIGHT) == glfw.PRESS)
    
    # update mouse position
    glfw.get_cursor_pos(window)

def mouse_move(window, xpos, ypos):
    # compute mouse displacement, save
    global lastx
    global lasty
    global button_left
    global button_middle
    global button_right
    
    dx = xpos - lastx
    dy = ypos - lasty
    lastx = xpos
    lasty = ypos
    
    # no buttons down: nothing to do
    if (not button_left) and (not button_middle) and (not button_right):
        return
    
    # get current window size
    width, height = glfw.get_window_size(window)
    
    # get shift key state
    PRESS_LEFT_SHIFT = glfw.get_key(
        window, glfw.KEY_LEFT_SHIFT) == glfw.PRESS
    PRESS_RIGHT_SHIFT = glfw.get_key(
        window, glfw.KEY_RIGHT_SHIFT) == glfw.PRESS
    mod_shift = (PRESS_LEFT_SHIFT or PRESS_RIGHT_SHIFT)
    
    # determine action based on mouse button
    if button_right:
        if mod_shift:
            action = mj.mjtMouse.mjMOUSE_MOVE_H
        else:
            action = mj.mjtMouse.mjMOUSE_MOVE_V
    elif button_left:
        if mod_shift:
            action = mj.mjtMouse.mjMOUSE_ROTATE_H
        else:
            action = mj.mjtMouse.mjMOUSE_ROTATE_V
    else:
        action = mj.mjtMouse.mjMOUSE_ZOOM
    
    mj.mjv_moveCamera(model, action, dx/height,
                      dy/height, scene, cam)

def scroll(window, xoffset, yoffset):
    action = mj.mjtMouse.mjMOUSE_ZOOM
    mj.mjv_moveCamera(model, action, 0.0, -0.05 * yoffset, scene, cam)

# Get the full path
dirname = os.path.dirname(__file__)
abspath = os.path.join(dirname, xml_path)
xml_path = abspath

# MuJoCo data structures
model = mj.MjModel.from_xml_path(xml_path)  # MuJoCo model
data = mj.MjData(model)  # MuJoCo data
cam = mj.MjvCamera()  # Abstract camera
opt = mj.MjvOption()  # visualization options

# Init GLFW, create window, make OpenGL context current, request v-sync
glfw.init()
window = glfw.create_window(1920, 1080, "UR5e Inverse Kinematics Demo", None, None)
glfw.make_context_current(window)
glfw.swap_interval(1)

# initialize visualization data structures
mj.mjv_defaultCamera(cam)
mj.mjv_defaultOption(opt)
scene = mj.MjvScene(model, maxgeom=10000)
context = mj.MjrContext(model, mj.mjtFontScale.mjFONTSCALE_150.value)

# install GLFW mouse and keyboard callbacks
glfw.set_key_callback(window, keyboard)
glfw.set_cursor_pos_callback(window, mouse_move)
glfw.set_mouse_button_callback(window, mouse_button)
glfw.set_scroll_callback(window, scroll)

# Set camera configuration
cam.azimuth = -130
cam.elevation = -5
cam.distance = 2
cam.lookat = np.array([0.0, 0.0, 0.5])

# Initialize the controller
init_controller(model, data)

# Set the controller callback
mj.set_mjcb_control(controller)

# Reset to home position
key_qpos = model.key("home").qpos
q_home = key_qpos.copy()
data.qpos[:] = q_home
mj.mj_forward(model, data)

# Target position and orientation
x_ref = 0.5      # Target X coordinate
y_ref = 0.2      # Target Y coordinate
z_ref = 0.3      # Target Z coordinate
phi_ref = 3.14   # Roll (around X-axis)
theta_ref = 0    # Pitch (around Y-axis)
psi_ref = 0      # Yaw (around Z-axis)

# Create initial target
apex_ref = np.array([x_ref, y_ref, z_ref])
alter_flag = True

# Control parameters
Kp = 0.5  # Proportional gain for IK
max_joint_velocity = 0.5  # Maximum joint velocity (rad/s)
damping_factor = 0.01  # Damping factor for DLS

print("Starting simulation...")
print(f"Target center: ({x_ref}, {y_ref}, {z_ref})")
print(f"Target orientation: roll={phi_ref}, pitch={theta_ref}, yaw={psi_ref}")
print("Press BACKSPACE to reset simulation")
print("Close window to exit")

# Main simulation loop
while not glfw.window_should_close(window):
    time_prev = data.time
    
    # Run simulation steps for 1/60 second
    while (data.time - time_prev < 1.0/60.0):
        # Get current end-effector position and orientation
        # site 0 is the end effector
        position_Q = data.site_xpos[0]  # Current position
        mat_Q = data.site_xmat[0]       # Current orientation matrix
        quat_Q = np.zeros(4)
        mj.mju_mat2Quat(quat_Q, mat_Q)  # Convert to quaternion
        
        # Convert quaternion to Euler angles (XYZ order)
        r_Q = Rotation.from_quat([quat_Q[1], quat_Q[2], quat_Q[3], quat_Q[0]])
        euler_Q = r_Q.as_euler('xyz')
        
        # Compute Jacobian matrix
        # jacp: position Jacobian (3x6)
        # jacr: rotation Jacobian (3x6)
        jacp = np.zeros((3, model.nu))
        jacr = np.zeros((3, model.nu))
        mj.mj_jac(model, data, jacp, jacr, position_Q, 7)  # body id 7 is the end effector
        
        # Stack to get full Jacobian (6x6)
        J = np.vstack((jacp, jacr))
        
        # Compute inverse Jacobian using damped least squares
        Jinv = damped_least_squares(J, damping_factor)
        
        # Change target every 5 seconds
        if (int(data.time) % 5 == 0) and alter_flag:
            apex_ref = random_cube_apex(x_ref, y_ref, z_ref)
            print(f"New target: {apex_ref}")
            alter_flag = False
        if (int(data.time) % 5 != 0):
            alter_flag = True
        
        # Desired pose
        X_ref = np.array([apex_ref[0], apex_ref[1], apex_ref[2], 
                          phi_ref, theta_ref, psi_ref])
        # Current pose
        X = np.concatenate((position_Q, euler_Q))
        # Error
        dX = X_ref - X
        
        # Apply proportional gain
        dX_scaled = Kp * dX
        
        # Compute joint velocity using inverse Jacobian
        dq = Jinv @ dX_scaled
        
        # Limit joint velocity
        dq_norm = np.linalg.norm(dq)
        if dq_norm > max_joint_velocity:
            dq = dq * max_joint_velocity / dq_norm
        
        # Update joint positions
        q_home += dq * 0.02  # Multiply by time step
        
        # Check joint limits
        q_home = check_joint_limits(q_home, model)
        
        # Apply to simulation
        data.qpos[:] = q_home
        mj.mj_forward(model, data)
        
        # Increment simulation time manually
        data.time += 0.02
    
    # Stop simulation if time limit reached
    if data.time >= simend:
        print(f"Simulation time limit ({simend}s) reached.")
        break
    
    # Get framebuffer viewport
    viewport_width, viewport_height = glfw.get_framebuffer_size(window)
    viewport = mj.MjrRect(0, 0, viewport_width, viewport_height)
    
    # Print camera configuration (helpful for initializing view)
    if print_camera_config == 1:
        print('cam.azimuth =', cam.azimuth, ';', 'cam.elevation =', cam.elevation, ';', 'cam.distance = ', cam.distance)
        print('cam.lookat =np.array([', cam.lookat[0], ',', cam.lookat[1], ',', cam.lookat[2], '])')
    
    # Update scene and render
    mj.mjv_updateScene(model, data, opt, None, cam, mj.mjtCatBit.mjCAT_ALL.value, scene)
    mj.mjr_render(viewport, scene, context)
    
    # Swap OpenGL buffers (blocking call due to v-sync)
    glfw.swap_buffers(window)
    
    # Process pending GUI events, call GLFW callbacks
    glfw.poll_events()

# Clean up
print("Simulation ended.")
glfw.terminate()
