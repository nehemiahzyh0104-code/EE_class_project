import mujoco
import mujoco.viewer
import numpy as np
import matplotlib.pyplot as plt
import os
import time
from scipy.signal import butter, filtfilt
import warnings
warnings.filterwarnings('ignore')

# 抑制Matplotlib的特定警告
import matplotlib
matplotlib.rcParams['figure.max_open_warning'] = 0

xml_path = '../../models/Pendulum/pendulum.xml'
dirname = os.path.dirname(__file__)
abspath = os.path.normpath(os.path.join(dirname, xml_path))

# --- 改进的PID控制器类 ---
class PIDController:
    def __init__(self, kp, ki, kd, dt, output_limits=(-np.inf, np.inf), anti_windup=True):
        """
        改进的PID控制器类
        
        Args:
            kp, ki, kd: 控制器增益
            dt: 时间步长
            output_limits: 输出限制 (min, max)
            anti_windup: 是否启用抗饱和
        """
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.dt = dt
        self.output_limits = output_limits
        self.anti_windup = anti_windup
        
        # 控制器状态
        self.integral = 0.0
        self.last_error = 0.0
        self.last_output = 0.0
        self.last_derivative = 0.0
        
        # 低通滤波器参数（用于微分项）
        self.alpha = 0.1  # 低通滤波器系数
        
    def reset(self):
        """重置控制器状态"""
        self.integral = 0.0
        self.last_error = 0.0
        self.last_output = 0.0
        self.last_derivative = 0.0
    
    def compute(self, setpoint, measurement, dt=None):
        """
        计算控制输出
        
        Args:
            setpoint: 目标值
            measurement: 测量值
            dt: 可选的时间步长，如果为None则使用初始化的dt
            
        Returns:
            output: 控制输出
        """
        if dt is None:
            dt = self.dt
            
        if dt <= 0:
            return self.last_output
        
        # 计算误差
        error = setpoint - measurement
        
        # 比例项
        P = self.kp * error
        
        # 积分项（带抗饱和）
        self.integral += error * dt
        
        # 积分抗饱和
        if self.anti_windup and self.output_limits[0] < self.output_limits[1]:
            # 计算无积分限制时的输出
            unlimited_output = P + self.ki * self.integral + self.kd * self.last_derivative
            
            # 如果输出饱和，停止积分
            if unlimited_output > self.output_limits[1] and error > 0:
                self.integral -= error * dt
            elif unlimited_output < self.output_limits[0] and error < 0:
                self.integral -= error * dt
        
        I = self.ki * self.integral
        
        # 微分项（带低通滤波）
        if dt > 0:
            derivative_raw = (error - self.last_error) / dt
            # 低通滤波以减少噪声
            derivative = self.alpha * derivative_raw + (1 - self.alpha) * self.last_derivative
            self.last_derivative = derivative
        else:
            derivative = self.last_derivative
        
        D = self.kd * derivative
        
        # 计算总输出
        output = P + I + D
        
        # 应用输出限制
        if self.output_limits[0] < self.output_limits[1]:
            output = np.clip(output, self.output_limits[0], self.output_limits[1])
        
        # 更新状态
        self.last_error = error
        self.last_output = output
        
        return output

# --- 角度归一化函数 ---
def normalize_angle(angle):
    """将角度归一化到[-π, π]区间"""
    return (angle + np.pi) % (2 * np.pi) - np.pi

# --- 加载模型 ---
try:
    model = mujoco.MjModel.from_xml_path(abspath)
    data = mujoco.MjData(model)
    print(f"成功加载模型: {abspath}")
    print(f"模型自由度: {model.nq}")
    print(f"控制输入数: {model.nu}")
except Exception as e:
    print(f"加载模型失败: {e}")
    print("请检查XML文件路径")
    exit(1)

# --- 控制参数 ---
# 倒立摆的倒立控制（目标角度=π）
TARGET_ANGLE = np.pi
DT = model.opt.timestep
SIMULATION_TIME = 10.0  # 仿真时间

# 改进的PID参数（需要调试）
# 对于倒立摆控制，通常需要较大的KD来提供阻尼
KP = 100.0   # 比例增益
KI = 1.0     # 积分增益
KD = 10.0    # 微分增益

# 初始化PID控制器
pid_controller = PIDController(
    kp=KP, 
    ki=KI, 
    kd=KD, 
    dt=DT,
    output_limits=(-5.0, 5.0),  # 限制扭矩输出
    anti_windup=True
)

# --- 数据存储 ---
time_history = []
angle_history = []
target_history = []
error_history = []
torque_history = []
integral_history = []
derivative_history = []

# 记录仿真开始时间
sim_start_time = time.time()

# 启动仿真
try:
    with mujoco.viewer.launch_passive(model, data) as viewer:
        # 设置初始条件（倒立摆从接近竖直向下位置开始）
        data.qpos[0] = 0.0  # 初始角度
        data.qvel[0] = 0.0  # 初始角速度
        mujoco.mj_forward(model, data)
        
        # 重置PID控制器
        pid_controller.reset()
        
        print(f"开始PID控制仿真")
        print(f"目标角度: {TARGET_ANGLE:.2f} rad ({TARGET_ANGLE*180/np.pi:.1f}°)")
        print(f"时间步长: {DT:.4f} s")
        print(f"仿真时间: {SIMULATION_TIME:.1f} s")
        print("-" * 50)
        
        # 主仿真循环
        while viewer.is_running() and data.time < SIMULATION_TIME:
            step_start = time.time()
            
            # 获取当前角度（归一化）
            current_angle = normalize_angle(data.qpos[0])
            
            # 计算误差（考虑角度环绕）
            error = normalize_angle(TARGET_ANGLE - current_angle)
            
            # PID控制计算扭矩
            torque = pid_controller.compute(0.0, error)  # 目标误差为0
            
            # 应用控制输入
            data.ctrl[0] = torque
            
            # 存储数据
            time_history.append(data.time)
            angle_history.append(current_angle)
            target_history.append(TARGET_ANGLE)
            error_history.append(error)
            torque_history.append(torque)
            integral_history.append(pid_controller.integral)
            derivative_history.append(pid_controller.last_derivative)
            
            # 执行仿真步
            mujoco.mj_step(model, data)
            
            # 同步可视化
            viewer.sync()
            
            # 实时同步
            elapsed = time.time() - step_start
            if elapsed < DT:
                time.sleep(DT - elapsed)
            else:
                print(f"警告: 仿真步超过时间步长 {elapsed:.4f} > {DT:.4f}")
                
        print(f"仿真完成, 实际运行时间: {time.time() - sim_start_time:.2f} 秒")
        
except Exception as e:
    print(f"仿真过程中发生错误: {e}")

# --- 绘制结果 ---
if time_history:  # 如果有数据
    time_history = np.array(time_history)
    angle_history = np.array(angle_history)
    error_history = np.array(error_history)
    torque_history = np.array(torque_history)
    
    # 创建图形
    fig, axes = plt.subplots(3, 2, figsize=(15, 10))
    
    # 1. 角度跟踪
    ax1 = axes[0, 0]
    ax1.plot(time_history, angle_history, 'b-', label='实际角度', linewidth=2)
    ax1.plot(time_history, target_history, 'r--', label='目标角度', linewidth=2)
    ax1.set_xlabel('时间 (s)')
    ax1.set_ylabel('角度 (rad)')
    ax1.set_title('角度跟踪')
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    ax1.set_ylim([-np.pi-0.5, np.pi+0.5])
    
    # 2. 误差
    ax2 = axes[0, 1]
    ax2.plot(time_history, error_history, 'g-', label='误差', linewidth=2)
    ax2.axhline(y=0, color='r', linestyle='--', alpha=0.5)
    ax2.set_xlabel('时间 (s)')
    ax2.set_ylabel('误差 (rad)')
    ax2.set_title('控制误差')
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    
    # 3. 控制扭矩
    ax3 = axes[1, 0]
    ax3.plot(time_history, torque_history, 'm-', label='控制扭矩', linewidth=2)
    ax3.axhline(y=pid_controller.output_limits[0], color='r', linestyle=':', alpha=0.5, label='扭矩限制')
    ax3.axhline(y=pid_controller.output_limits[1], color='r', linestyle=':', alpha=0.5)
    ax3.set_xlabel('时间 (s)')
    ax3.set_ylabel('扭矩 (Nm)')
    ax3.set_title('控制输入')
    ax3.grid(True, alpha=0.3)
    ax3.legend()
    
    # 4. 相平面图（角度 vs 角速度）
    ax4 = axes[1, 1]
    # 由于qvel没有存储，这里用角度差分近似速度
    if len(angle_history) > 1:
        angle_velocity = np.gradient(angle_history, time_history)
        ax4.plot(angle_history[:-1], angle_velocity[:-1], 'c-', alpha=0.7)
        ax4.set_xlabel('角度 (rad)')
        ax4.set_ylabel('角速度 (rad/s)')
        ax4.set_title('相平面图')
        ax4.grid(True, alpha=0.3)
    
    # 5. 积分项
    ax5 = axes[2, 0]
    ax5.plot(time_history, integral_history, 'orange', label='积分项', linewidth=2)
    ax5.set_xlabel('时间 (s)')
    ax5.set_ylabel('积分值')
    ax5.set_title('积分项历史')
    ax5.grid(True, alpha=0.3)
    ax5.legend()
    
    # 6. 微分项
    ax6 = axes[2, 1]
    ax6.plot(time_history, derivative_history, 'brown', label='微分项', linewidth=2)
    ax6.set_xlabel('时间 (s)')
    ax6.set_ylabel('微分值')
    ax6.set_title('微分项历史')
    ax6.grid(True, alpha=0.3)
    ax6.legend()
    
    plt.suptitle(f'倒立摆PID控制 (KP={KP}, KI={KI}, KD={KD})', fontsize=16)
    plt.tight_layout()
    
    # 计算性能指标
    print("\n" + "="*50)
    print("性能统计:")
    print("="*50)
    print(f"最终误差: {error_history[-1]:.4f} rad")
    print(f"均方根误差: {np.sqrt(np.mean(error_history**2)):.4f} rad")
    print(f"最大误差: {np.max(np.abs(error_history)):.4f} rad")
    print(f"平均绝对扭矩: {np.mean(np.abs(torque_history)):.4f} Nm")
    print(f"最大扭矩: {np.max(np.abs(torque_history)):.4f} Nm")
    
    # 检查是否稳定
    last_errors = error_history[-int(len(error_history)/10):]  # 最后10%的数据
    if np.max(np.abs(last_errors)) < 0.1:  # 误差小于0.1 rad
        print("状态: 稳定 ✓")
    else:
        print("状态: 不稳定 ✗")
    
    plt.show()
else:
    print("没有仿真数据可绘制")
